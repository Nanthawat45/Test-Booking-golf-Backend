import User from "../models/User.js";
import jwt from "jsonwebtoken";
import bcrypt from "bcryptjs"; // à¹ƒà¸Šà¹‰ bcryptjs à¸ªà¸³à¸«à¸£à¸±à¸šà¸à¸²à¸£à¹€à¸‚à¹‰à¸²à¸£à¸«à¸±à¸ªà¸£à¸«à¸±à¸ªà¸œà¹ˆà¸²à¸™
import Booking from "../models/Booking.js";
import mongoose from "mongoose";
import Asset from "../models/Asset.js";

export const generateToken = (userId, res) => { //=>{...} Arrow Function
  const token = jwt.sign({ userId }, process.env.JWT_SECRET, { // à¹€à¸‚à¹‰à¸²à¸£à¸«à¸±à¸ª JWT
    expiresIn: "1d",
  });

  res.cookie("jwt", token, { // ðŸ”¹ à¸•à¸±à¹‰à¸‡à¸„à¹ˆà¸² cookie à¸ªà¸³à¸«à¸£à¸±à¸š JWT
    httpOnly: true, //à¸«à¹‰à¸²à¸¡ JavaScript à¸à¸±à¹ˆà¸‡ frontend à¸­à¹ˆà¸²à¸™ cookie
    secure: process.env.NODE_MODE !== "development", // à¸•à¸£à¸§à¸ˆà¸ªà¸­à¸šà¸§à¹ˆà¸²à¸–à¹‰à¸²à¹€à¸›à¹‡à¸™ development à¸•à¹‰à¸­à¹ƒà¸Šà¹ˆ http à¸–à¹‰à¸²à¹€à¸›à¹‡à¸™ production à¸•à¹‰à¸­à¸‡à¹€à¸›à¹‡à¸™ https
    sameSite: "Lax", // à¸›à¹‰à¸­à¸‡à¸à¸±à¸™ CSRF (à¹ƒà¸Šà¹‰ "None" à¸–à¹‰à¸²à¸ˆà¸°à¸ªà¹ˆà¸‡à¸ˆà¸²à¸ frontend à¸•à¹ˆà¸²à¸‡ origin) //à¸›à¹‰à¸­à¸‡à¸à¸±à¸™ cookie à¸«à¸¥à¸¸à¸”
    maxAge: 24 * 60 * 60 * 1000, // 1 à¸§à¸±à¸™
  });
};

// ðŸ”¹ à¸¥à¸‡à¸—à¸°à¹€à¸šà¸µà¸¢à¸™à¸œà¸¹à¹‰à¹ƒà¸Šà¹‰
export const registerUser = async (req, res) => { // = async (req, res) => { à¸„à¸·à¸­ Asynchronous
  const { name, email, password, role } = req.body;  // à¸”à¸¶à¸‡à¸‚à¹‰à¸­à¸¡à¸¹à¸¥à¸ˆà¸²à¸ req.body à¸‹à¸¶à¹ˆà¸‡à¸„à¸·à¸­ JSON à¸—à¸µà¹ˆà¸œà¸¹à¹‰à¹ƒà¸Šà¹‰à¸à¸£à¸­à¸à¸¡à¸²à¸ˆà¸²à¸ frontend
  try {
      const userExists = await User.findOne({ email }); // à¸•à¸£à¸§à¸ˆà¸ªà¸­à¸šà¸§à¹ˆà¸²à¸¡à¸µà¸œà¸¹à¹‰à¹ƒà¸Šà¹‰à¸—à¸µà¹ˆà¸¡à¸µà¸­à¸µà¹€à¸¡à¸¥à¸™à¸µà¹‰à¸­à¸¢à¸¹à¹ˆà¹à¸¥à¹‰à¸§à¸«à¸£à¸·à¸­à¹„à¸¡à¹ˆ
  if (userExists) {
    return res.status(400).json({ message: "User already exists" });// à¸–à¹‰à¸²à¸¡à¸µà¸œà¸¹à¹‰à¹ƒà¸Šà¹‰à¸—à¸µà¹ˆà¸¡à¸µà¸­à¸µà¹€à¸¡à¸¥à¸™à¸µà¹‰à¸­à¸¢à¸¹à¹ˆà¹à¸¥à¹‰à¸§ à¹ƒà¸«à¹‰à¸ªà¹ˆà¸‡à¸‚à¹‰à¸­à¸„à¸§à¸²à¸¡à¸§à¹ˆà¸² à¸¡à¸µà¸œà¸¹à¹‰à¹ƒà¸Šà¹‰à¸­à¸¢à¸¹à¹ˆà¹à¸¥à¹‰à¸§
  }

  const hashedPassword = await bcrypt.hash(password, 10);  // à¹€à¸‚à¹‰à¸²à¸£à¸«à¸±à¸ªà¸£à¸«à¸±à¸ªà¸œà¹ˆà¸²à¸™à¸”à¹‰à¸§à¸¢ bcrypt //10 à¸„à¸·à¸­à¸ˆà¸³à¸™à¸§à¸™à¸£à¸­à¸šà¹ƒà¸™à¸à¸²à¸£à¹€à¸‚à¹‰à¸²à¸£à¸«à¸±à¸ª (salt rounds)
  const user = await User.create({ name, email, password: hashedPassword, role }); // à¸ªà¸£à¹‰à¸²à¸‡à¸œà¸¹à¹‰à¹ƒà¸Šà¹‰à¹ƒà¸«à¸¡à¹ˆà¹ƒà¸™à¸à¸²à¸™à¸‚à¹‰à¸­à¸¡à¸¹à¸¥

  if (user) {  // à¸–à¹‰à¸²à¸ªà¸£à¹‰à¸²à¸‡à¸œà¸¹à¹‰à¹ƒà¸Šà¹‰à¸ªà¸³à¹€à¸£à¹‡à¸ˆ
    generateToken(user._id, res);  // à¸ªà¸£à¹‰à¸²à¸‡ JWT à¹à¸¥à¸°à¸•à¸±à¹‰à¸‡à¸„à¹ˆà¸² cookie
    res.status(201).json({ //à¸ªà¹ˆà¸‡à¸‚à¹‰à¸­à¸¡à¸¹à¸¥à¸œà¸¹à¹‰à¹ƒà¸Šà¹‰à¸à¸¥à¸±à¸šà¹„à¸›à¹ƒà¸«à¹‰ (à¸¢à¸·à¸™à¸¢à¸±à¸™à¸§à¹ˆà¸²à¸ªà¸¡à¸±à¸„à¸£à¸ªà¸³à¹€à¸£à¹‡à¸ˆ)
      _id: user._id,
      name: user.name,
      email: user.email,
      role: user.role,
    });
  } else {
    res.status(400).json({ message: "Invalid user data" });  // à¸–à¹‰à¸²à¹„à¸¡à¹ˆà¸ªà¸²à¸¡à¸²à¸£à¸–à¸ªà¸£à¹‰à¸²à¸‡à¸œà¸¹à¹‰à¹ƒà¸Šà¹‰à¹„à¸”à¹‰ à¹ƒà¸«à¹‰à¸ªà¹ˆà¸‡à¸‚à¹‰à¸­à¸„à¸§à¸²à¸¡à¸§à¹ˆà¸² à¸‚à¹‰à¸­à¸¡à¸¹à¸¥à¸œà¸¹à¹‰à¹ƒà¸Šà¹‰à¹„à¸¡à¹ˆà¸–à¸¹à¸à¸•à¹‰à¸­à¸‡
  }
  } catch (error) {
    console.log("Error in registerUser:", error);// à¸‚à¹‰à¸­à¸œà¸´à¸”à¸žà¸¥à¸²à¸”à¹ƒà¸™à¸à¸²à¸£à¸¥à¸‡à¸—à¸°à¹€à¸šà¸µà¸¢à¸™à¸œà¸¹à¹‰à¹ƒà¸Šà¹‰
  }
};

// ðŸ”¹ à¹€à¸‚à¹‰à¸²à¸ªà¸¹à¹ˆà¸£à¸°à¸šà¸š
export const loginUser = async (req, res) => {
  const { email, password } = req.body;
  const user = await User.findOne({ email });

  if (user && (await bcrypt.compare(password, user.password))) { //compare à¹€à¸›à¸£à¸µà¸¢à¸šà¹€à¸—à¸µà¸¢à¸šà¸£à¸«à¸±à¸ªà¸œà¹ˆà¸²à¸™à¸—à¸µà¹ˆà¸œà¸¹à¹‰à¹ƒà¸Šà¹‰à¸à¸£à¸­à¸à¸à¸±à¸šà¸£à¸«à¸±à¸ªà¸œà¹ˆà¸²à¸™à¸—à¸µà¹ˆà¹€à¸à¹‡à¸šà¹„à¸§à¹‰à¹ƒà¸™à¸à¸²à¸™à¸‚à¹‰à¸­à¸¡à¸¹à¸¥
    generateToken(user._id, res); // à¸ªà¸£à¹‰à¸²à¸‡ JWT à¹à¸¥à¸°à¸•à¸±à¹‰à¸‡à¸„à¹ˆà¸² cookie
    res.json({
      _id: user._id,
      name: user.name,
      email: user.email,
      role: user.role,
    });
  } else {
    res.status(401).json({ message: "Invalid email or password" }); // à¸–à¹‰à¸²à¸­à¸µà¹€à¸¡à¸¥à¸«à¸£à¸·à¸­à¸£à¸«à¸±à¸ªà¸œà¹ˆà¸²à¸™à¹„à¸¡à¹ˆà¸–à¸¹à¸à¸•à¹‰à¸­à¸‡ à¹ƒà¸«à¹‰à¸ªà¹ˆà¸‡à¸‚à¹‰à¸­à¸„à¸§à¸²à¸¡à¸§à¹ˆà¸² à¸­à¸µà¹€à¸¡à¸¥à¸«à¸£à¸·à¸­à¸£à¸«à¸±à¸ªà¸œà¹ˆà¸²à¸™à¹„à¸¡à¹ˆà¸–à¸¹à¸à¸•à¹‰à¸­à¸‡
  }
};

// ðŸ”¹ à¸”à¸¶à¸‡à¸‚à¹‰à¸­à¸¡à¸¹à¸¥à¹‚à¸›à¸£à¹„à¸Ÿà¸¥à¹Œ
export const getUserProfile = async (req, res) => { //Asynchronous 
  const user = await User.findById(req.user.id); //findById à¸„à¸·à¸­

  if (user) {
    res.json({
       _id: user.id, 
       name: user.name, 
       email: user.email, 
       role: user.role,
     });
  } else {
    res.status(404).json({ message: "User not found" }); // à¸–à¹‰à¸²à¹„à¸¡à¹ˆà¸žà¸šà¸œà¸¹à¹‰à¹ƒà¸Šà¹‰ à¹ƒà¸«à¹‰à¸ªà¹ˆà¸‡à¸‚à¹‰à¸­à¸„à¸§à¸²à¸¡à¸§à¹ˆà¸² à¹„à¸¡à¹ˆà¸žà¸šà¸œà¸¹à¹‰à¹ƒà¸Šà¹‰
  }
};

// ðŸ”¹ à¹à¸­à¸”à¸¡à¸´à¸™à¸ªà¸£à¹‰à¸²à¸‡à¸£à¸«à¸±à¸ª caddy starter
export const registerByAdmin = async (req, res) => {
  const { name, email, password, role } = req.body;

  const allowedRoles = ['admin', 'caddy', 'starter'];
  if (!allowedRoles.includes(role)) {
    return res.status(400).json({ message: "Invalid role specified" });
  }

  const adminUser = await User.findById(req.user.id);
  if (!adminUser || adminUser.role !== 'admin') {
    return res.status(403).json({ message: "Only admins can perform this action" });
  }

  const userExists = await User.findOne({ email });
  if (userExists) {
    return res.status(400).json({ message: "User already exists" });
  }

  const hashedPassword = await bcrypt.hash(password, 10);
  const newUser = await User.create({ name, email, password: hashedPassword, role });

  if (newUser) {
    res.status(201).json({
      _id: newUser.id,
      name: newUser.name,
      email: newUser.email,
      role: newUser.role,
    });
  } else {
    res.status(400).json({ message: "Failed to create user" });
  }
};

// ðŸ”¹ à¸”à¸¶à¸‡à¸œà¸¹à¹‰à¹ƒà¸Šà¹‰à¸—à¸±à¹‰à¸‡à¸«à¸¡à¸”
export const getAllUsers = async (req, res) => {
  try {
    const users = await User.find({});
    res.status(200).json(users);
  } catch (error) {
    console.error("Error in getAllUsers:", error);
    res.status(500).json({ message: error.message || 'Server error' });
  }
};

// ðŸ”¹ à¸”à¸¶à¸‡à¸œà¸¹à¹‰à¹ƒà¸Šà¹‰à¸”à¹‰à¸§à¸¢ ID
export const getUserById = async (req, res) => {
  try {
    const user = await User.findById(req.params.id).select('-password'); // à¹„à¸¡à¹ˆà¸£à¸§à¸¡ password
    if (user) {
      res.status(200).json(user);
    } else {
      res.status(404).json({ message: 'User not found' });
    }
  } catch (error) {
    console.error("Error in getUserById:", error);
    res.status(500).json({ message: error.message || 'Server error' });
  }
};

// ðŸ”¹ à¸­à¸±à¸›à¹€à¸”à¸•à¸‚à¹‰à¸­à¸¡à¸¹à¸¥à¸œà¸¹à¹‰à¹ƒà¸Šà¹‰
export const updateUser = async (req, res) => {
  try {
    const user = await User.findById(req.params.id);

    if (user) {
      user.name = req.body.name || user.name;
      user.email = req.body.email || user.email;
      user.role = req.body.role || user.role;

      if (req.body.password) {
        user.password = await bcrypt.hash(req.body.password, 10);
      }

      const updatedUser = await user.save();
      res.status(200).json({
        _id: updatedUser._id,
        name: updatedUser.name,
        email: updatedUser.email,
        role: updatedUser.role,
      });
    } else {
      res.status(404).json({ message: 'User not found' });
    }
  } catch (error) {
    console.error("Error in updateUser:", error);
    res.status(500).json({ message: error.message || 'Server error' });
  }
};

// ðŸ”¹ à¸¥à¸šà¸œà¸¹à¹‰à¹ƒà¸Šà¹‰
export const deleteUser = async (req, res) => {
  try {
    const user = await User.findById(req.params.id);

    if (user) {
      await user.deleteOne();
      res.status(200).json({ message: 'User removed' });
    } else {
      res.status(404).json({ message: 'User not found' });
    }
  } catch (error) {
    console.error("Error in deleteUser:", error);
    res.status(500).json({ message: error.message || 'Server error' });
  }
};

// ðŸ”¹ Controller à¸ªà¸³à¸«à¸£à¸±à¸šà¸­à¸±à¸›à¹€à¸”à¸•à¸ªà¸–à¸²à¸™à¸°à¹à¸„à¸”à¸”à¸µà¹‰
export const updateCaddyStatus = async (req, res) => {
  const { id } = req.params; 
  const { newStatus } = req.params; 

  const allowedStatuses = ['available', 'booked', 'onDuty', 'offDuty', 'resting', 'unavailable'];
  if (!allowedStatuses.includes(newStatus)) {
    return res.status(400).json({ message: `Invalid status: ${newStatus}. Allowed statuses are: ${allowedStatuses.join(', ')}` });
  }

  try {
    const caddy = await User.findById(id);

    if (!caddy) {
      return res.status(404).json({ message: "Caddy not found." });
    }

    if (caddy.role !== 'caddy') {
      return res.status(403).json({ message: "Only users with 'caddy' role can have their status updated via this endpoint." });
    }

    let message = `Caddy '${caddy.name}' status updated from '${caddy.caddyStatus}' to '${newStatus}'.`;

    switch (caddy.caddyStatus) {
      case 'booked': 
        if (newStatus === 'onDuty') {
          caddy.caddyStatus = newStatus;
        } else {
          return res.status(400).json({ message: `Caddy status cannot be changed from 'booked' to '${newStatus}'. Only 'onDuty' is allowed.` });
        }
        break;
      case 'onDuty': 
        if (newStatus === 'offDuty' || newStatus === 'resting' || newStatus === 'available') { 
          caddy.caddyStatus = newStatus;
        } else {
          return res.status(400).json({ message: `Caddy status cannot be changed from 'onDuty' to '${newStatus}'.` });
        }
        break;
      case 'available': 
        if (newStatus === 'unavailable' || newStatus === 'resting') {
            caddy.caddyStatus = newStatus;
        } else {
            return res.status(400).json({ message: `Caddy status cannot be changed from 'available' to '${newStatus}'.` });
        }
        break;
      default: 
        caddy.caddyStatus = newStatus;
        break;
    }

    const updatedCaddy = await caddy.save();
    res.status(200).json({ message, caddy: updatedCaddy });

  } catch (error) {
    console.error(`Error updating caddy status for ${id}:`, error);
    res.status(500).json({ error: error.message || "Failed to update caddy status." });
  }
};

// ðŸ”¹ à¸¥à¸‡à¸Šà¸·à¹ˆà¸­à¸­à¸­à¸ (Logout)
export const logoutUser = (req, res) => {
  res.cookie('jwt', '', {
    httpOnly: true,
    expires: new Date(0), // à¸à¸³à¸«à¸™à¸”à¹ƒà¸«à¹‰ cookie à¸«à¸¡à¸”à¸­à¸²à¸¢à¸¸à¸—à¸±à¸™à¸—à¸µ
  });
  res.status(200).json({ message: 'Logged out successfully' });
};

export const getAvailableCaddies = async (req, res) => {
  try {
    const caddies = await User.find({ role: 'caddy', caddyStatus: 'available' });
    res.status(200).json(caddies);
  } catch (error) {
    console.error("Error in getAvailableCaddies:", error);
    res.status(500).json({ message: error.message || 'Server error' });
  }
};